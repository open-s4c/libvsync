/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2023. All rights reserved.
 * Author: Huawei Dresden Research Center
 * Create: Wed Jun 28 13:06:56 CEST 2023
 */

let ext = ext & ((~IW) * M)
let int = int | (IW * M)
let rfe = rf & ext
let coe = co & ext
let fre = fr & ext
let rfi = rf & int
let coi = co & int
let fri = fr & int

(** Atomicity **)
empty rmw & (fre;coe)

(** SC per location **)
acyclic co | rf | fr | po-loc

let Marked = RLX | ACQ | REL | SC
let Plain = ~Marked
let Acq = ACQ | (SC & R)
let Rel = REL | (SC & W)

(** Ordering **)
let dep = (data;rfi | addr | ctrl)*;(ctrl | addr | data)

(* Plain writes can be elided and therefore are generally not ordered by things that order writes *)
let bob = [Acq];po | po;[Rel] | [SC];po;[SC] | po;[SC & F];po | [R];po;[Acq & F];po | po;[Rel & F];po;[W & Marked]
let ppo = bob | [Marked];(dep | coi | fri);[W & Marked]

(* 
   If there is no w-race, plain writes are slightly better-behaved: if they are read-from, then either 
    1) they exist and provide ordering, or 
    2) an older store with the same value exists and that store is also a candidate for the read, in which case the ordering provided in this graph is ignored in the graph in which the older store is observed
   
   However, the plain writes  may not exist in the form supposed by dependencies etc.
   This is especially true for data dependencies, which may be speculatively elided.
   Only ctrl and addr dependencies are not elided, because the compiler is not allowed to speculatively modify memory regions (which might be protected by a lock owned by another thread).
*)
let WRF-ppo = po;[Rel & F];po;[W & Plain] | [Marked];(ctrl | addr);[W & Plain]

let hb = ppo | WRF-ppo | rfe | fre | coe
acyclic hb

(** Data Races **)

let w-race-fix = ([Marked] | ppo);hb+;([Marked] | ppo)

let w-race = coe \ w-race-fix
let w-racy = [domain(w-race)] | [range(w-race)]
flag ~empty w-racy as w-data-race

let r-race-fix = w-race-fix | ([Marked] | ppo);hb+; WRF-ppo

let r-race = (fre | rfe) \ r-race-fix
let r-racy = [domain(r-race)] | [range(r-race)]
let obs-dep = (data;rfi)*;(ctrl | addr | data;rfe)
flag ~empty [domain(obs-dep)] & r-racy as r-data-race
